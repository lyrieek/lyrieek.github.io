<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<script src="https://d3js.org/d3.v6.min.js" charset="utf-8"></script>
	<style>
	div {
		text-align: center;
	}

	svg {
		background: ivory
	}

	svg.editingMode {
		background: lightyellow
	}

	</style>
	<script>
	window.onload = function() {
		const width = 190 * 3;
		const height = 190 * 3;
		const padding = 25;
		let way = 19;
		let playerRole = 1; //1: black, 0:white
		let currentRole = 1;
		let isEditingMode = false;

		const svg = d3.select('#container')
			.append('svg')
			.attr('width', width + padding * 2 + 'px')
			.attr('height', height + padding * 2 + 'px');


		for (let y = 0; y < way; y++) {
			let gridLineXArray = [];
			let gridLineYArray = [];

			for (let x = 0; x < way; x++) {
				gridLineXArray.push([width / way * x + padding, width / way * y + padding])
				gridLineYArray.push([height / way * y + padding, height / way * x + padding])
			}

			svg.append("text")
				.attr("x", "0")
				.attr('y', height / way * (y + 1))
				.text(19 - y)

			svg.append("text")
				.attr("x", width / way * y + padding - 5)
				.attr('y', height + padding)
				.text(String.fromCharCode(65 + y))

			svg.append("path")
				.attr("class", "line")
				.attr('stroke', '#000')
				.attr("d", d3.line()(gridLineXArray));

			svg.append("path")
				.attr("class", "line")
				.attr('stroke', '#000')
				.attr("d", d3.line()(gridLineYArray));
		}

		//绘制星位 9路以上才绘制星位
		if (way > 9) {
			const star = [];
			star.push([3, 3]);
			star.push([way - 4, 3]);
			star.push([3, way - 4]);
			star.push([way - 4, way - 4]);
			//19路及以上才绘制全星位
			if (way >= 19) {
				const val = (way - way % 2) / 2;
				star.push([val, 3]);
				star.push([3, val]);
				star.push([val, val]);
				star.push([val, way - 4]);
				star.push([way - 4, val]);
			}
			for (const item of star) {
				svg.append("circle")
					// .attr('fill', '#000')
					.attr('r', '4')
					.attr("cx", width / way * item[0] + padding)
					.attr("cy", height / way * item[1] + padding);
			}
		}

		const calcChessPiecePoint = function(offset) {
			let compareNum = (offset - padding) % (width / way);
			if (compareNum > width / way / 2) {
				compareNum -= width / way;
			}
			return offset - compareNum;
		}

		const removeChessPieceHandler = (e) => {
			if (isEditingMode) {
				e.target.remove();
			}
		}

		const rendererChessPiece = function(chessPiece) {
			chessPieces.current = chessPiece;
			if (currentRole === 1) {
				chessPiece.attr('class', 'CP_black')
				chessPiece.attr('fill', '#000')
			} else {
				chessPiece.attr('class', 'CP_white')
				chessPiece.attr('fill', '#FFF')
			}
			if (!isEditingMode) {
				currentRole = Math.abs(currentRole - 1);
				return;
			}
			chessPiece.on('click', removeChessPieceHandler);
		}

		const chessPieces = Object.create(null);

		chessPieces.selecting = svg.append("circle")
			.attr('fill', '#777')
			.attr('r', 13)
			.attr('stroke', "black")
			.style('display', 'none')

		svg.on("mousemove", function(d, i) {
			if (currentRole === 1) {
				chessPieces.selecting.attr('fill', '#555')
			} else {
				chessPieces.selecting.attr('fill', '#CCC')
			}
			// (d.offsetX - padding) / (width / way)
			chessPieces.selecting.attr('cx', calcChessPiecePoint(d.offsetX));
			chessPieces.selecting.attr('cy', calcChessPiecePoint(d.offsetY));
			// chessPieces.selecting.attr('cx', d.offsetX);

			chessPieces.selecting.style('display', undefined);
		})
		chessPieces.selecting.on('click', () => rendererChessPiece(chessPieces.selecting.clone()))
		svg.on("mouseout", function(d, i) {
			if (d.offsetX < 0) {
				chessPieces.selecting.attr('display', 'none')
			}
		})

		d3.select('#editCP_btn').on('click', (e) => {
			isEditingMode = e.target.checked;
			if (isEditingMode) {
				svg.attr('class', 'editingMode')
				d3.select('#editingToolbar').style('display', 'inline');
				if (currentRole === 1) {
					d3.select('#switchBlackCP').attr('checked', 'checked');
				} else {
					d3.select('#switchWhiteCP').attr('checked', 'checked');
				}

				d3.selectAll('.CP_black,.CP_white').on('click', removeChessPieceHandler);
			} else {
				svg.attr('class', null)
				d3.select('#editingToolbar').style('display', 'none');
				d3.selectAll('.CP_black,.CP_white').on('click', null);
			}
		})
		d3.selectAll('[name="role"]').on('click', (e) => {
			currentRole = Number(e.target.value);
		})

	};

	</script>
</head>

<body>
	<div id="container"></div>
	<div id="toolbar">
		<input type="checkbox" name="edit" id="editCP_btn" />
		<label for="editCP_btn">编辑模式</label>
		<span id="editingToolbar" style="display: none;">
			<input type="radio" name="role" value=1 id="switchBlackCP" />
			<label for="switchBlackCP">黑棋</label>
			<input type="radio" name="role" value=0 id="switchWhiteCP" />
			<label for="switchWhiteCP">白棋</label>
		</span>
	</div>
</body>

</html>
